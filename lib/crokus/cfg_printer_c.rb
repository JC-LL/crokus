module Crokus

  class PrinterC

    attr_accessor :cfg

    def initialize
      @visited=[]
      @prp=PrettyPrinter.new
    end

    def print cfg
      puts " |-->[+] generating C code from cfg '#{cfg.name}'"
      @cfg=cfg
      code=Code.new
      code << "//"+"-"*60
      code << "// automatically generated by Crokus compiler"
      code << "// date : #{Time.now.strftime("%a %d,%B %Y - %H:%M:%S")}"
      code << "//"+"-"*60
      code.newline
      code << "#include <stdio.h>"
      code << "#include <stdlib.h>"
      code.newline
      io=[decl_inputs,decl_outputs].join(',')
      code << "int #{cfg.name}(#{io}){"
      code.indent=2
      code << decl_vars()
      code << decl_loop_indexes()
      code << decl_arrays()
      code << visit_rec(cfg.starter)
      code << output_assigns()
      code << "return 0;"
      code.indent=0
      code << "}"
      code.newline
      code << main(cfg)
      puts code.finalize
      code.save_as "#{cfg.name}.c"
    end

    def main cfg
      code=Code.new
      code << "int main(void){"
      code.indent=2
      inputs,outputs=[],[]
      cfg.infos["inputs"].each do |input|
        code << "int #{input} = #{rand 0..255};"
        inputs << input
      end
      cfg.infos["outputs"].each do |output|
        code << "int #{output};"
        outputs << "&#{output}"
      end
      params=[inputs,outputs].flatten.join(',')
      code << "#{cfg.name}(#{params});"
      cfg.infos["outputs"].each do |output|
        code << "printf(\"#{output} = %d\\n\",#{output});"
      end
      code << "return 0;"
      code.indent=0
      code << "}"
      code
    end

    def decl_inputs
      if h=cfg.infos["inputs"]
        return h.map{|ident| "int #{ident}"}
      end
    end

    def decl_outputs
      if h=cfg.infos["outputs"]
        return h.map{|ident| "int *#{ident}"}
      end
    end

    def decl_vars
      code=Code.new
      if h=cfg.infos["int_vars"]
        h.each{|ident| code << "int #{ident} = #{rand(0..255)};"}
      end
      code.newline
      code
    end

    def decl_loop_indexes
      code=Code.new
      if cfg.infos["loop_indexes"]
        code << "// loop indexes"
        cfg.infos["loop_indexes"].each do |index|
          code << "int #{index};"
        end
        code.newline
      end
      code
    end

    def decl_arrays
      code=Code.new
      cfg.infos["internal_arrays"].each do |h|
        name,size_lit=h.first
        size_int=size_lit.to_s.to_i
        init=Array.new(size_int){rand(255)}.join(",")
        size=size_lit.accept(@prp)
        code << "int #{name}[#{size}] ={#{init}};"
      end
      code.newline
      code
    end

    def output_assigns
      code=Code.new
      code.newline
      code << "//------- output assignments ------"
      if ary=cfg.infos["output_assigns"]
        ary.each{|h|
          out,expr=h.first
          rhs=expr.accept(@prp)
          code << "*#{out} = #{rhs};"
        }
      end
      code
    end

    def visit_rec bb
      unless bb.nil? or @visited.include?(bb)
        if bb.infos[:start_if]
          gen_if(bb)
        elsif bb.infos[:start_while]
          gen_while(bb)
        elsif bb.infos[:start_for]
          gen_for(bb)
        else
          gen_plain(bb)
        end
      end
    end

    def gen_plain bb
      code=Code.new
      @visited << bb
      #code << "// bb #{bb.label}"
      bb.stmts.each{|assign|
        code << assign.accept(@prp)
      }
      code << visit_rec(bb.nextBranch)
      code
    end

    def gen_if bb
      code=Code.new
      @visited << bb
      #code << "// bb 'if' #{bb.label}"
      bb.stmts.each{|stmt| code << stmt.accept(@prp)}
      cond=bb.infos[:cond].accept(@prp)
      code << "if (#{cond}){"
      code.indent=2
      code << visit_rec(bb.trueBranch)
      code.indent=0
      code << "}"
      code << "else {"
      code.indent=2
      code << visit_rec(bb.falseBranch)
      code.indent=0
      code << "}"
      code
    end

    def gen_while bb
      code=Code.new
      @visited << bb
      bb.stmts.each{|stmt| code << stmt.accept(@prp)}
      cond=bb.infos[:cond].accept(@prp)
      code << "while (#{cond}){"
      code.indent=2
      code << visit_rec(bb.trueBranch)
      code.indent=0
      code << "}"
      code << visit_rec(bb.falseBranch)
      code
    end

    def gen_for bb
      code=Code.new
      @visited << bb
      #code << "// bb 'for' #{bb.label}"
      bb.stmts.each{|stmt| code << stmt.accept(@prp)}
      index=bb.infos["loop_index"]
      index_bound=bb.infos["loop_index_bound"]
      code << "for(#{index}=0;#{index} < #{index_bound};#{index}++){"
      code.indent=2
      code << visit_rec(bb.trueBranch)
      code.indent=0
      code << "}"
      code << visit_rec(bb.falseBranch)
      code
    end
  end
end
